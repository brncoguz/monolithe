General Concepts
================


Introduction
------------

VSDK provides a set of objects that allows the manipulation of VSD entities very easily. It deals with all possible CRUD operations. VSDK is based on `Bambou`, which defines all these low level operations. You will never use `Bambou` directly when working with VSDK. However, you need to understand the basics of this library, because all the logic resides in it. VSDK objects are simple autogenerated objects that are all inherited from the same `Bambou` class and they all work the same.

`Bambou` is composed of the following classes:

* :class:`bambou.NURESTConnection`: A low level class that is used each time there's a need to communicate with the VSD server.
* :class:`bambou.NURESTModelController` :Singleton that controls all defined model objects.
* :class:`bambou.NURESTBasicUser`: Represents the user used for authentication and fetching root objects.
* :class:`bambou.NURESTLoginController`: Represents a ReST communication session, using a `NURESTUser` for authentication.
* :class:`bambou.NURESTObject`: Parent class of all ReST entities. All VSDK objects are inheriting from this class.
* :class:`bambou.NURESTFetcher`: Class used to get children of a `NURESTObject`.
* :class:`bambou.NURESTPushCenter`: Class that deals with intercepting and rerouting VSD ReST Push Notifications.

.. note:: The most important classes you need to know are :class:`bambou.NURESTObject`, :class:`bambou.NURESTFetcher` and :class:`bambou.NURESTPushCenter`.



NURESTObject
------------

:class:`bambou.NURESTObject` is the parent class of all VSDK entities.


ReST Names
++++++++++

All :class:`bambou.NURESTObject` subclasses **must** implement a given method that will return the actual ReST name of the objects. For instance, the ReST name of  a VSD enterprise is `enterprise` while it is `egressacltemplate` for Egress Security Policies. This name is used to forges API and also can be used as an unique key for identifying random VSDK objects.

.. note:: ReST names are auto generated. You never need to manually define them.


ReST API URI generation
+++++++++++++++++++++++

:class:`bambou.NURESTObject` is able to forge all the URI needed to interact with the server through the ReST API.

For instance, if an object with a ReST name set to `object` needs to get the list of children with ReST name set to `subobject`, `Bambou` will create the following endpoing URL `/objects/{id}/subobjects`. if an object with a ReST name set to `object` needs to fetch itself, the generated URL will be `/objects/{id}`

`Bambou` deals with plural. So when using the VSDK the only URL you will ever enter is the VSD API base URL endpoint.

.. note:: The ReST base URL is pulled from the session. We'll discuss this later.


Exposing ReST attributes
++++++++++++++++++++++++

Exposed attributes will be converted and sent to the server when you do CRUD operations. That way, if an object has an attribute :py:attr:`name`, it can be marked as a ReST attribute. When saving the object, the value of :py:attr:`name` will be put into the JSON structure that will be sent to the server, or automatically populated from a JSON structure coming from the server.

Not only the attribute can be exposed, but also its type and other informations like read only, allowed values, format etc.

.. note:: exposing ReST Attributes is also auto generated. You never need to manually expose new attributes.


CRUD Operations
+++++++++++++++

:class:`bambou.NURESTObject` allows to perform all sorts of CRUD operations.

.. automethod:: bambou.NURESTObject.fetch
    :noindex:

.. automethod:: bambou.NURESTObject.save
    :noindex:

.. automethod:: bambou.NURESTObject.delete
    :noindex:

.. automethod:: bambou.NURESTObject.create_child_object
    :noindex:

.. automethod:: bambou.NURESTObject.assign_objects
    :noindex:

.. automethod:: bambou.NURESTObject.instantiate_child_object
    :noindex:


.. note:: All these methods require the current :class:`bambou.NURESTObject` to have a valid :py:attr:`ID`.

.. note:: You may notice that there is no creation method. Creation is always happening from a parent object and is done using.

.. note:: You may notice that an optional parameter :py:attr:`callback` is present. VSDK can work in a completely asynchronous mode. We'll explain this later.



Converting to and from a Python Dictionary
++++++++++++++++++++++++++++++++++++++++++

:class:`bambou.NURESTObject` allows quick and easy conversion from and to python dictionaries

.. automethod:: bambou.NURESTObject.from_dict
    :noindex:

.. automethod:: bambou.NURESTObject.to_dict
    :noindex:

.. note:: you never need to process to the actual JSON conversion when sending info to the server. :class:`bambou.NURESTConnection` will do that automatically.



NURESTFetcher
-------------

:class:`bambou.NURESTFetcher` are objects allowing a :class:`bambou.NURESTObject` to fetch its children :class:`bambou.NURESTObject`. All :class:`bambou.NURESTObject` have one or more fetchers, unless it's a final object in the VSD model hierarchy. :class:`bambou.NURESTFetcher` provides a lot of possibility regarding the way you want to get a given children list. It can deal with simple object fetching, pagination, filtering, request headers, grouping etc.


Fetching Children List
++++++++++++++++++++++

:class:`bambou.NURESTFetcher` has three importants methods:

.. automethod:: bambou.NURESTFetcher.fetch
    :noindex:

.. automethod:: bambou.NURESTFetcher.get
    :noindex:

.. automethod:: bambou.NURESTFetcher.get_first
    :noindex:


Discussion about Fetchers
+++++++++++++++++++++++++

Fetcher is a powerfull concept that makes the process of getting child objects completely generic and code friendly. :class:`bambou.NURESTObject` provides methods that allow to deal programatically with the fetchers and children lists in a completely generic way.

.. automethod:: bambou.NURESTObject.fetcher_for_rest_name
    :noindex:

.. automethod:: bambou.NURESTObject.fetchers
    :noindex:

.. automethod:: bambou.NURESTObject.children_rest_names
    :noindex:


This allows complete abstract programatic operations on any objects.

For instance, the following function will create a new :py:class:`NUMetadata` to the entire hierarchy of children from a given object that has been created before a certain date:

.. code-block:: python
    :linenos:

    def apply_metadata_to_all_children(root_object, metadata, filter=None):

        # Loop on all declared children fetchers
        for fetcher in root_object.children_fetchers():

            # Fetch the list of the children
            children = fetcher.get(filter=filter, conn)

            # Loop on all fetched children
            for child in children:

                # Add the metadata to the current children
                child.create_child_object(metadata, async=True)

                # Start over recursively on the children of the current child
                apply_metadata_to_all_children(child, metadata)


    enterprise = NUEnterprise(id="xxxx-xxxx-xxx-xxxx")
    metadata = NUMetadata(name="my metadata", blob="hello world!")

    apply_metadata_to_all_children(enterprise, metadata, filter="creationDate > '01-01-2015'")



NUVSDSession
---------------------
We talked about how to do a lot of things, but all of them needs to be done once your are authenticated. This section describes how to authenticate yourself. VSDK provides a shortcut to do all of this in one line, the :class:`vsdk.NUVSDSession`. The previous section's code is strictly equivalent to the following:

.. code-block:: python
    :linenos:

    session = NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://myvsd:8443", version="3.2")
    session.start()
    current_user = session.user

    # business as usual



NURESTPushCenter
----------------

The VSD API supports client side push through a long polling connection. ReST clients can connect to that channel and will get a notification as soon as he or someone else in the system changes something. This events are filtered by permissions, which means that if someone change a property of an object you cannot see, you won't get notified. VSDK provides the :class:`bambou.NURESTPushCenter`, which is a singleton that encapsulates the logic to deal with this event channel. It runs in its own thread and will call registered callbacks when it receives a push.

Using the NURESTPushCenter
++++++++++++++++++++++++++

Only 4 methods are important:

.. automethod:: bambou.NURESTPushCenter.start
    :noindex:

.. automethod:: bambou.NURESTPushCenter.stop
    :noindex:

.. automethod:: bambou.NURESTPushCenter.add_delegate
    :noindex:

.. automethod:: bambou.NURESTPushCenter.remove_delegate
    :noindex:

Simple Example
++++++++++++++

Here is an sample code that will print the push data on every push:

.. code-block:: python
    :linenos:

    NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://vsd:8443" version="3.2").start()

    def on_receive_push(data):
        print(data);

    NURESTPushCenter().add_delegate(on_receive_push);
    NURESTPushCenter().start()

    # default stupid run loop. don't do that in real life :)
    while True:
        sleep(1000)


Advanced Example
++++++++++++++++

A more interesting use case:

.. code-block:: python
    :linenos:

    class EnterpriseUsersController (Object):

        def __init__(self, parent_enterprise):

            self.parent_enterprise = parent_enterprise

            # we assume the push center is already configured
            NURESTPushCenter().add_delegate(self.on_receive_user_push)

        def on_receive_user_push(self, data):

            # a single push can contains multiple events as they are clobbed together by the server if needed
            for event in data["events"]:

                # if the push is not about users, we don't care
                if event["entityType"] != NUUser.rest_name:
                    continue

                # We get the data. Server sends an array of entities, but it can contains only one object
                user_info = event["entities"][0]

                # if the pushed user is not part of the parent enterprise, we also don't care
                if user_info["parentID"] != self.parent_enterprise.id:
                    continue

                # create a transient NUUser from the data
                pushed_user = NUUser(data=user_info)

                if event["type"] == "CREATE":
                    # locally insert the object in the correct children list
                    self.enterprise.add_child(pushed_user)

                elif event["type"] == "UPDATE":
                    # locally replace a user with the new version in the correct children list
                    self.enterprise.update_child(pushed_user)

                elif event["type"] == "DELETE":
                    # locally remove the user from the correct children list
                    self.enterprise.remove_child(pushed_user)


    NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://vsd:8443" version="3.2").start()

    enterprise = NUEnterprise(id=some_id)
    enterprise_users_controller = EnterpriseUsersController(enterprise)

    # from now on, the user list of enterprise will always be up to date from the server!

    while True:
        sleep(1000)

