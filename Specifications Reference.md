# Monolithe Specifications Reference

Monolithe is using well defined specifications to generate sdks and documentations. This document describe how Specifications works and how to create your own.


## Specifications Folder

Specifications are files that must have the extension `.spec`. One and only one object must be described in a Specification file and all Specification files must be in the same subdirectory.


## Specification API Version

The specification folder **must** contains a special file named `api.version`. This file contains the backend api version the Specification Files are referering to.

For instance:

	$ cat api.version
	> 3.2

The file **must** only contain the version. Carriage return and blank space will be stripped.


## Specification File

A Specification File describes a particular object of the API. It will tell what are the parent and children APIs, information about itself, and informations about its attributes.

It **must** contains valid json data. And the structure is following (the order of the key does not make any difference).


	{
		“apis”: {
			“children”: {
				…
			},
			“parents”: {
				…
			},
			“self” : {
				…
			}
		},
		“model”: {
			…
			“attributes”: {
				“attribute1”: {
					…
				},
				…,
				“attributeN”: {
					…
				}
			}
		}
	}


### The Model Section

The `model` describes the object itself: it **must** contains the following keys:

#### RESTName
The singlar name of the object. This will be used as a unique key to identify and object from the sdks. It will be used each time something must reference a kind of object.

For example:

	“RESTName”: “unicorn”

#### resourceName
Usually, the plural version of the `RESTName`. This will be used to generate the API calls like `/unicorns/{id}`

For example:

	“resourceName”: “unicorns”

#### entityName
Will be used for the class name of the SDK. As it is impossible for Monolithe to guess your capitalization system, you must give this attribute. If not set, a capitalized version `RESTName` will be used, but you should always provide it yourself.

For example:

	“entityName”: “Unicorn”

#### package
Used to group the objects in the generated API documentation.

For example:

	“package”: “magic”

#### description
Will be used to populate the api documentation. You should put extensive description of the object, what it represents, what it does etc.

For example:

	“description”: “Unicorn is a pretty cool mystic creature.”

#### extends
The list of other Specification Files the current Specification inherits from. More information on that later.

For example:

	“extends”: [
		“@base”, 
		“@namedobject”
	]
	
### The Attributes Section
The list of Attributes the model has. It is a dictionary where the key is the name of the attribute, and the content, all its characteristics.

For example:

	“attributes” : {
		“name”: { … },
		“description”: {…}
	}


The attribute must contains its charateristics. Each characteristic define one behavior of the attribute, and multiple things can happens during the sdk/documentation generation process according to these characteristics.

#### allowedChars
Python-style regular expression that will be used to validates the content of the attribute.

> Only working for attributes of type `string`.

Example:

	“allowedChars”: “[A-Za-z]”

#### allowedChoices
Array containing the list of allowed values the attribute can take.

> Only working for attributes of type `enum`.

Example:

	“allowedChoices”: [
		“MALE”, 
		“FEMALE”, 
		“OTHER”
	]

#### autogenerated
Boolean that tells if the value of the attribute will be autogenerated by the server.

> `autogenated` attributes are always `readOnly`

Example: 

	“autogenerated”: false

#### availability
Reserved for later usage.

#### channel
Reserved for later usage.

#### creationOnly
Boolean that tells if the value can’t be modified once the object has been created.

Example:

	“creationOnly”: false

#### defaultOrder
Boolean that tells if that property is used as the default ordering key when fetching a list of objects.

> Only one attribute can be marked as `defaultOrder` per Specification.

Example:

	“defaultOrder”: true

#### defaultValue
string containing what will be the default value of the attribute if the attributes is not set when sending the object to the server.

Example:

	“defaultValue”: “hello world”

#### description
string containing the description of the attribute. This will be used when Monolithe generates the API documentation.

Example:

	“description”: “This attribute is very cool!”

#### exposed
Reserved for later usage.

#### filterable
Boolean that tells if the object can be filtered using that attribute.

Example:

	“filterable”: true

#### format
format for the attribute. It can be one of the following:

- `phone`
- `IPV6`
- `IPV4`
- `email`

Example:

	“format”: “phone”

#### minLength / maxLength
Integer indicating the min / max length of an attribute. 

> Only available for attribute of type `string`.

Example:

	“minLength”: 1,
	“maxLength”: 1024

#### minValue / maxValue
Integer indicating the min / max value of an attribute. 

> Only available for attribute of type `int` or `float`.

Example:

	“minValue”: -100,
	“maxValue”: 100

#### orderable
Boolean that tells if the attribute can be used to order a query.

Example:

	“orderable”: true

#### readOnly
Boolean that tells if the attribute is read only

Example:

	“readOnly”: false

#### required
Boolean that tells if the attribute is required or can be sent as `null`

> Note that `null` is different than 0.

Example:

	“required”: true

#### transient
Reserved for later usage.

#### type
The type of the attribute. It can be one of the following:

- `string`
- `boolean`
- `int`
- `float`
- `enum`
- `list`
- `object`

#### unique
Boolean that tells if the attribute value is unique.

> Depending on the server business logic implementation, it could mean unique in the context of its parent, or unique in the global context

Example:

	“unique”: true


### The APIs Section

The API section describes all the APIs that can be used to get this object itself (`self`), get it from a parent (`parents`) or get its children (`children`).

The each kind of api are using the same structure of api definition. The structure of an api definition looks like:

	“/parent/{id}/children” : {
		“RESTName”: <rest-name>,
		“resourceName: <resource-name>,
	  “entityName”: <entity-name>
		“operations”: [
			…
		]
	}

#### The API

The key used for describing an api is the api path itself. It contains a wildcard `{id}` that must be written that way.

For example:

> the example below describes the API for a root object `unicorn` that has `legs` as a children.
  
	“children”: {
		“/unicorns/{id}/legs” : {
			“RESTName”: “leg”,
			“resourceName: “legs”,
			“entityName”: “Leg”
			“operations”: [
				…
			]
		}
	},
	“parents” : {
		“/unicorns”: {
			“RESTName”: “unicorn”,
			“resourceName: “unicorns”,
			“entityName”: “Unicorn”
			“operations”: [
				…
			]
	},
	“self” : {
		“/unicorns/{id}”: {
			“RESTName”: “unicorn”,
			“resourceName: “unicorns”,
			“entityName”: “Unicorn”
			“operations”: [
				…
			]
	}

###### RESTName

References the remote object `RESTName` as described in its own `model` section.

###### resourceName

References the remote object `resourceName` as described in its own `model` section.

###### entityName

References the remote object `entityName` as described in its own `model` section.

##### operations
The operation section describes what kind of operation is available from the api.

For example:

		“/unicorns/{id}”: {
			“RESTName”: “unicorn”,
			“resourceName: “unicorns”,
			“entityName”: “Unicorn”
			“operations”: [
				{
					"availability": null,
					“method”: “GET”
				},
				{
					"availability": null,
					“method”: “DELETE”
				},
				{
					"availability": null,
					“method”: “PUT”
				}
			]

###### availability

Reserved for later usage.

###### method

The method of the operation. This can be one of the valid following HTTP verbs:

- `GET`
- `POST`
- `PUT`
- `DELETE`
- `HEAD`


## Inheritance

As briefly discussed previously, a Specification File can inherit informations from another one. The list of Specification Files a Specification File inherits from is given using the `extends` section of the `model` section.

### Model Inheritance
It is possible to inherits models values. The parent Specification can be a real declared object, or just a file that only contains the section you need.

For instance, we can have the following:

> The specifications are simplified for readablity

	$ cat horse.spec
	{
		…
		“model”: {
			“RESTName”: “horse”,
			“attributes”: [
				“name”: {…},
				“age”: {…},
				“size”: {…}
			]
		…
	}

	$ cat unicorn.spec
		{
		…
		“model”: {
			“extends”: [“horse”],
			“RESTName”: “unicorn”,
			“attributes”: [
				“hornSize”: {…}
			]
		…
	}

This will generate two objects, one `Horse` with `name`, `age` and `size` as attributes and one `Unicorn` with `name`, `age` and `size` and `hornSize`.

### API Inheritance
It is also possible to inherits APIs. For instance if you want all the objects in your model to have a common children api, say `metadatas`, you can do the following:

	$ cat @metadatas-capable.spec
	{
		“apis”: {
			“children”: {
				“[__RESOURCE_NAME__]/{id}/metadatas”: {
					…
				}
			}
		}
	}

	$ cat horse.spec
	{
		…
		“model”: {
			“extends”: [“@metadatas-capable”],
			“RESTName”: “unicorn”,
			“attributes”: [
				“hornSize”: {…}
			]
		…
	}

Then both `Horse` and `Unicorn` object will have `metadatas` as child API.

You can notice the `[__RESOURCE_NAME__]` token. This will be replaced by the actual Specification `resourceName` value set in its `model` section.

#### Inheritance-only Specification Files

In the previous example, you can notice the `@` preceding the `metadata-capable.spec` Specification File name. This will make Monolithe to not generate an actual object from that specification. It’s very useful to set some files that regroups common attributes and apis, but doesn’t necessarily need to be generated as an api object.

#### Multiple inheritance

The `extends` property is an array, so it is possible to inherit apis and attributes from multiple files.

For instance:

	“extends”: [
		“@metadata-capable”,
		“@named-object”,
		“horse”
	]

All apis and models will be merged into the current Apecification File. In case of collision in apis or attribute, the last extension declared in the list will win.

For instance, in the previous example, if both `@metadata-capable` and `horse` contains a `package` attribute in the `model`, section, the one in `horse` will be the one used in the end. 

