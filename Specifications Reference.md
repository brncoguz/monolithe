# Monolithe Specifications Reference

Monolithe is using well defined specifications to generate sdks and documentations. This document describes how Specifications work and how to create your own.


## Specifications Folder

Specifications are files that must have the extension `.spec`. One and only one object must be described in a Specification file and all Specification files must be in the same subdirectory.


## Specification API Version

The specification folder **must** contains a special file named `api.info`. This file contains the backend basic information about the api.

For instance:

	$ cat api.info
	{
        "version": "3.2",
        "prefix": "api",
        "root": "root"
    }

The file **must** only contain the version. Carriage return and blank space will be stripped.


## Specification File

A Specification File describes a particular object of the API. It will tell what are the parent and children APIs, information about itself, and informations about its attributes.

It **must** contains valid json data. And the structure is following (the order of the key does not make any difference).


	{
		“apis”: {
			“children”: {
				…
			},
			“parents”: {
				…
			},
			“self” : {
				…
			}
		},
		“model”: {
			…
			“attributes”: {
				“attribute1”: {
					…
				},
				…,
				“attributeN”: {
					…
				}
			}
		}
	}


### The Model Section

The `model` describes the object itself: it **must** contains the following keys:

#### rest_name
The singlar name of the object. This will be used as a unique key to identify and object from the sdks. It will be used each time something must reference a kind of object.

For example:

	“rest_name”: “unicorn”

#### resource_name
Usually, the plural version of the `rest_name`. This will be used to generate the API calls like `/unicorns/{id}`

For example:

	“resource_name”: “unicorns”

#### entity_name
Will be used for the class name of the SDK. As it is impossible for Monolithe to guess your capitalization system, you must give this attribute. If not set, a capitalized version `rest_name` will be used, but you should always provide it yourself.

For example:

	“entity_name”: “Unicorn”

#### package
Used to group the objects in the generated API documentation.

For example:

	“package”: “magic”

#### description
Will be used to populate the api documentation. You should put extensive description of the object, what it represents, what it does etc.

For example:

	“description”: “Unicorn is a pretty cool mystic creature.”

#### extends
The list of other Specification Files the current Specification inherits from. More information on that later.

For example:

	“extends”: [
		“@base”,
		“@namedobject”
	]

### The Attributes Section
The list of Attributes the model has. It is a dictionary where the key is the name of the attribute, and the content, all its characteristics.

For example:

	“attributes” : {
		“name”: { … },
		“description”: {…}
	}


The attribute must contains its charateristics. Each characteristic define one behavior of the attribute, and multiple things can happen during the sdk/documentation generation process according to these characteristics.

#### allowedChars
Python-style regular expression that will be used to validates the content of the attribute.

> Only working for attributes of type `string`.

Example:

	“allowedChars”: “[A-Za-z]”

#### allowedChoices
Array containing the list of allowed values the attribute can take.

> Only working for attributes of type `enum`.

Example:

	“allowedChoices”: [
		“MALE”,
		“FEMALE”,
		“OTHER”
	]

#### autogenerated
Boolean that tells if the value of the attribute will be autogenerated by the server.

> `autogenated` attributes are always `read_only`

Example:

	“autogenerated”: false

#### availability
Reserved for later usage.

#### channel
Reserved for later usage.

#### creation_only
Boolean that tells if the value can’t be modified once the object has been created.

Example:

	“creation_only”: false

#### default_order
Boolean that tells if that property is used as the default ordering key when fetching a list of objects.

> Only one attribute can be marked as `default_order` per Specification.

Example:

	“default_order”: true

#### default_value
string containing what will be the default value of the attribute if the attributes is not set when sending the object to the server.

Example:

	“default_value”: “hello world”

#### description
string containing the description of the attribute. This will be used when Monolithe generates the API documentation.

Example:

	“description”: “This attribute is very cool!”

#### exposed
Reserved for later usage.

#### filterable
Boolean that tells if the object can be filtered using that attribute.

Example:

	“filterable”: true

#### format
format for the attribute. It can be one of the following:

- `phone`
- `IPV6`
- `IPV4`
- `email`

Example:

	“format”: “phone”

#### min_length / max_length
Integer indicating the min / max length of an attribute.

> Only available for attribute of type `string`.

Example:

	“min_length”: 1,
	“max_length”: 1024

#### min_value / max_value
Integer indicating the min / max value of an attribute.

> Only available for attribute of type `int` or `float`.

Example:

	“min_value”: -100,
	“max_value”: 100

#### orderable
Boolean that tells if the attribute can be used to order a query.

Example:

	“orderable”: true

#### read_only
Boolean that tells if the attribute is read only

Example:

	“read_only”: false

#### required
Boolean that tells if the attribute is required or can be sent as `null`

> Note that `null` is different than 0.

Example:

	“required”: true

#### transient
Reserved for later usage.

#### type
The type of the attribute. It can be one of the following:

- `string`
- `boolean`
- `int`
- `float`
- `enum`
- `list`
- `object`

#### unique
Boolean that tells if the attribute value is unique.

> Depending on the server business logic implementation, it could mean unique in the context of its parent, or unique in the global context

Example:

	“unique”: true


### The APIs Section

The API section describes all the APIs that can be used to get this object itself, get it from a parent or get its children.

The each kind of api are using the same structure of api definition. The structure of an api definition looks like:

	“/parent/{id}/children” : {
		“rest_name”: <rest-name>,
		“resource_name: <resource-name>,
	  “entity_name”: <entity-name>
		“operations”: […]
	}

The key used for describing an api is the api path itself. It contains a wildcard `{id}` that must be written that way.

#### API information

All APIs **must** contain the following keys:

- `rest_name`: References the remote object `rest_name` as described in its own `model` section.
- `resource_name`: References the remote object `resource_name` as described in its own `model` section
- `entity_name`: References the remote object `entity_name` as described in its own `model` section.

#### API Operations

The `operations` section of an `api` describes what kind of operations is available for it.

For example:

		“operations”: [
			{
				"availability": null,
				“method”: <method>
			}
		]

Operations **must** contain the following keys:

- `availability`: Reserved for later usage.
- `method`: The method of the operation. This can be one of the valid following HTTP verbs: `GET`, `POST`, `PUT`, `DELETE` or `HEAD`

#### Children APIs
The Children APIs section contains a list of available apis from the object described by the current Specification File.

For example:

	“children”: {
		“/unicorns/{id}/legs” : {
			“rest_name”: “leg”,
			“resource_name: “legs”,
			“entity_name”: “Leg”
			“operations”: [
				{
					"availability": null,
					“method”: “GET”
				},
				{
					"availability": null,
					“method”: “POST”
				}
			]
		}
	}

This means it is possible to call:

	GET /unicorns/3/legs # get the list a legs of unicorn3
	POST /unicorns/3/legs # create a new leg for unicorn3

> Usally, only `GET` and `POST` are available to a children api. But there is an exception when you want to associate two objects together. Then in that case you can add the `PUT` operation. Just note that doing `PUT /parent/{id}/children` **requires** passing an array of valid id (`[“1”, “3”]`) instead of a json structure representing the children.

#### Parent APIs
The Parent APIs section contains all the other apis from where a list of the objects described in the current Specification File can be accessed from.

For example:

	“parents” : {
		“/unicorns”: {
			“rest_name”: “unicorn”,
			“resource_name: “unicorns”,
			“entity_name”: “Unicorn”
			“operations”: [
				{
					"availability": null,
					“method”: “GET”
				},
				{
					"availability": null,
					“method”: “POST”
				}
			]
		}
	}

This means it is possible to call:

	GET /unicorns # get the list of unicorns
	POST /unicorns # create a new unicorn

> `PUT` and `DELETE` cannot be set in a `parent` api.

#### Self APIs
The Self APIs section contains all the other apis from where the object described in the current Specification File can be accessed from.

For example:

	“self” : {
		“/unicorns/{id}”: {
			“rest_name”: “unicorn”,
			“resource_name: “unicorns”,
			“entity_name”: “Unicorn”
			“operations”: [
				{
					"availability": null,
					“method”: “GET”
				},
				{
					"availability": null,
					“method”: “PUT”
				},
				{
					"availability": null,
					“method”: “DELETE”
				}
			]
		}
	}

This means it is possible to call

	GET /unicorns/3 # get the unicorn3
	PUT /unicorns/3 # update the unicorn3
	DELETE /unicorns/3 # delete the unicorn3

> `POST` cannot be set in a `self` api.

## Inheritance

As briefly discussed in a previous section, a Specification File can inherit information from other ones. The list of Specification Files a Specification File inherits from is given using the `extends` section of the `model` section.

### Model Inheritance
It is possible to inherits models values. The parent Specification can be a real declared object, or just a file that only contains the section you need.

For instance, we can have the following:

> The specifications are simplified for readablity

	$ cat horse.spec
	{
		…
		“model”: {
			“rest_name”: “horse”,
			“attributes”: [
				“name”: {…},
				“age”: {…},
				“size”: {…}
			]
		…
	}

	$ cat unicorn.spec
		{
		…
		“model”: {
			“extends”: [“horse”],
			“rest_name”: “unicorn”,
			“attributes”: [
				“hornSize”: {…}
			]
		…
	}

This will generate two objects, one `Horse` with `name`, `age` and `size` as attributes and one `Unicorn` with `name`, `age` and `size` and `hornSize`.

### API Inheritance
It is also possible to inherit APIs. For instance if you want all the objects in your model to have a common children api, say `metadatas`, you can do the following:

	$ cat @metadatas-capable.spec
	{
		“apis”: {
			“children”: {
				“[[resource_name]]/{id}/metadatas”: {
					…
				}
			}
		}
	}

	$ cat horse.spec
	{
		…
		“model”: {
			“extends”: [“@metadatas-capable”],
			“rest_name”: “unicorn”,
			“attributes”: [
				“hornSize”: {…}
			]
		…
	}

Then both `Horse` and `Unicorn` object will have `metadatas` as child API.

You can notice the `[[resource_name]]` token. This will be replaced by the actual Specification `resource_name` value set in its `model` section.

> It is also possible to use `[[entity_name]]` and `[[rest_name]]` as tokens.

#### Inheritance-only Specification Files

In the previous example, you can notice the `@` preceding the `metadatas-capable.spec` Specification File name. This will make Monolithe to not generate an actual object from that specification. It’s very useful to set some files that regroups common attributes and apis, but doesn’t necessarily need to be generated as an api object.

#### Multiple inheritance

The `extends` property is an array, so it is possible to inherit apis and attributes from multiple files.

For instance:

	“extends”: [
		“@metadatas-capable”,
		“@named-object”,
		“horse”
	]

All apis and models will be merged into the current Apecification File. In case of collision in apis or attribute, the last extension declared in the list will win.

For instance, in the previous example, if both `@metadatas-capable` and `horse` contains a `package` attribute in the `model`, section, the one in `horse` will be the one used in the end.

