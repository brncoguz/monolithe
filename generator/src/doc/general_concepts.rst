General Concepts
================


Introduction
------------

VSDK provides a set of objects that allows the manipulation of VSD entities very easily. It deals with all possible CRUD operations. VSDK is based on `Bambou`, which defines all these low level operations. You will never use `Bambou` directly when working with VSDK. However, you need to understand the basics of this library, because all the logic resides in it. VSDK objects are simple autogenerated objects that are all inherited from the same `Bambou` class and they all work the same.

`Bambou` is composed of the following classes:

.. class:: NURESTConnection

    A low level class that is used each time there's a need to communicate with the VSD server.

.. class:: NURESTModelController

    Singleton that controls all defined model objects.

.. class:: NURESTUser

    Represents the user used for authentication and fetching root objects.

.. class:: NURESTLoginController

    Represents a ReST communication session, using a `NURESTUser` for authentication.

.. class:: NURESTObject

    Parent class of all ReST entities. All VSDK objects are inheriting from this class.

.. class:: NURESTFetcher

    Class used to get children of a `NURESTObject`.

.. class:: NURESTPushCenter

    Class that deals with intercepting and rerouting VSD ReST Push Notifications.


.. note:: The most important classes you need to know are :py:class:`NURESTObject`, :py:class:`NURESTFetcher` and :py:class:`NURESTPushCenter`.



NURESTObject
------------

:py:class:`NURESTObject` is the parent class of all VSDK entities.


ReST Names
++++++++++

All :py:class:`NURESTObject` subclasses **must** implement a given method that will return the actual ReST name of the objects. For instance, the ReST name of  a VSD enterprise is `enterprise` while it is `egressacltemplate` for Egress Security Policies. This name is used to forges API and also can be used as an unique key for identifying random VSDK objects.

.. note:: ReST names are auto generated. You never need to manually define them.


ReST API URI generation
+++++++++++++++++++++++

:py:class:`NURESTObject` is able to forge all the URI needed to interact with the server through the ReST API.

For instance, if an object with a ReST name set to `object` needs to get the list of children with ReST name set to `subobject`, `Bambou` will create the following endpoing URL `/objects/{id}/subobjects`. if an object with a ReST name set to `object` needs to fetch itself, the generated URL will be `/objects/{id}`

`Bambou` deals with plural. So when using the VSDK the only URL you will ever enter is the VSD API base URL endpoint.

.. note:: The ReST base URL is pulled from the session. We'll discuss this later.


Exposing ReST attributes
++++++++++++++++++++++++

Exposed attributes will be converted and sent to the server when you do CRUD operations. That way, if an object has an attribute :py:attr:`name`, it can be marked as a ReST attribute. When saving the object, the value of :py:attr:`name` will be put into the JSON structure that will be sent to the server, or automatically populated from a JSON structure coming from the server.

Not only the attribute can be exposed, but also its type and other informations like read only, allowed values, format etc.

.. note:: exposing ReST Attributes is also auto generated. You never need to manually expose new attributes.


CRUD Operations
+++++++++++++++

:py:class:`NURESTObject` allows to perform all sorts of CRUD operations.

.. method:: fetch([callback=None])

    Gets the latest version of the object from the server.

    Example:

        >>> enterprise = NUEnterprise(id="xxx-xxx-xxx-xxx")
        >>> enterprise.fetch() # will get the enterprise with id "xxx-xxx-xxx-xxx"
        >>> print enterprise.name
        "My Enterprise"


.. method:: save([callback=None])

    Saves the current state of the object in the server.

    Example:

        >>> enterprise.name = "My Super Enterprise"
        >>> enterprise.save() # will save the new name in the server


.. method:: delete([callback=None])

    Deletes the object from the server.

    Example:

        >>> enterprise.delete() # will delete the enterprise from the server


.. method:: create_child_object(nurest_object[, callback=None])

    Creates another :py:class:`NURESTObject` as a child of the current object.

    Example:

        >>> group = NUGroup(name="Super Guys")
        >>> enterprise.create_child_object(group) # the new group as been created in the enterprise


.. method:: assign_objects(objects, nurest_object_type[, callback=None])

    Assigns a bunch of objects to the current object (for instance, putting users into a group).

    Example:

        >>> group.assign_objects([user1, user2, user3], NUUser.rest_name) # user1, user2 and user3 are now part of the group


.. method:: instantiate_child_object(nurest_object, from_template[, callback=None])

    Creates the object as an instance of the given template.

    Example:

        >>> enterprise = NUEnterprise(id="xxxx-xxxx-xxx-xxxx") # create a VSDK object NUEnterprise with an existing ID (or retrieve one)
        >>> domain_template = NUDomainTemplate(id="yyyy-yyyy-yyyy-yyyy") # create a VSDK object NUDomainTemplate with an existing ID (or retrieve one)
        >>> domain = NUDomain(name="my new instance") # create a new NUDomain to be intantiated from domain_template
        >>>
        >>> enterprise.instantiate_child_object(domain, domain_template) # instatiate the new domain in the server


.. note:: All these methods require the current :py:class:`NURESTObject` to have a valid :py:attr:`ID`.

.. note:: You may notice that there is no creation method. Creation is always happening from a parent object and is done using.

.. note:: You may notice that an optional parameter :py:attr:`callback` is present. VSDK can work in a completely asynchronous mode. We'll explain this later.



Converting to and from a Python Dictionary
++++++++++++++++++++++++++++++++++++++++++

:py:class:`NURESTObject` allows quick and easy conversion from and to python dictionaries

.. method:: from_dict(dictionary)

    Sets all the exposed ReST attribues from the given dictionary

    Example:

        >>> info = {"name": "my group", "private": False}
        >>> group = NUGroup()
        >>> group.from_dict(info)
        >>> print "name: %s - private: %s" % (group.name, group.private)
        "name: my group - private: False"


.. method:: to_dict()

    Convert the current object into a Dictionary using all exposed ReST attributes

    Example::
        >>> print group.to_dict()
        {"name": "my group", "private": False, "ID": "xxxx-xxx-xxxx-xxx", ...}

.. note:: you never need to process to the actual JSON conversion when sending info to the server. :py:class:`NURESTConnection` will do that automatically.



NURESTFetcher
-------------

:py:class:`NURESTFetchers` are objects allowing a :py:class:`NURESTObject` to fetch its children :py:class:`NURESTObjects`. All :py:class:`NURESTObjects` have one or more fetchers, unless it's a final object in the VSD model hierarchy. :py:class:`NURESTFetcher` provides a lot of possibility regarding the way you want to get a given children list. It can deal with simple object fetching, pagination, filtering, request headers, grouping etc.


Fetching Children List
++++++++++++++++++++++

:py:class:`NURESTFetcher` has one important method:

.. method:: fetch([filter=None[, order_by=None[, group_by=[][, page=None[, page_size=None[, commit=True[, async=False[, callback=None]]]]]]]])

    Gets the list of children objects it manages and add them into the its :py:class:`NURESTObject` declared list.
    For instance a :py:class:`NUUsersFetcher` of :py:class:`NUEnterprise` will get a list of :py:class:`NUUser` and put them into the property :py:attr:`users`
    of the :py:class:`NUEnterprise`.

    Returns:

        Tuple containing the fetcher itself, the fetcher owner, the list of fetched objects and the :py:class:`NURESTConnection` that was used.

        .. note:: You don't need to use this tuple is you work in synchronous mode. We'll talk more about the asynchronous mode later.

    Example:

        >>> myenterprise.domains_fetcher.fetch() # fetch domains in an enterprise
        >>> print myenterprise.domains # print the list of fetched objects
        [<NUDomain at xxx>, <NUDomain at yyyy>, <NUDomain at zzz>]


Discussion about Fetchers
+++++++++++++++++++++++++

Fetcher is a powerfull concept that makes the process of getting child objects completely generic and code friendly. :py:class:`NURESTObject` provides methods that allow to deal programatically with the fetchers and children lists in a completely generic way.

.. method:: children_rest_names()

    Gets the list of all possible children ReST names.

    Example:

        >>> application = NUApplication()
        >>> application.children_rest_names()
        ["flow", "tier"]


.. method:: children_for_rest_name(rest_name)

    Gets a particular children list based on a given ReST name.

    Example:

        >>> application = NUApplication(id="xxx-xxx-xxx")
        >>> application.tiers_fetcher.fetch()
        >>> print application.children_for_rest_name(NUTier.rest_name)
        [<NUTier at xxx>, <NUTier at yyy>]


.. method:: children_lists()

    Gets a list of all children list;

    Example:

        >>> application = NUApplication(id="xxx-xxx-xxx")
        >>> application.children_lists.fetch()
        >>> print application.children_for_rest_name(NUTier.rest_name)
        [[<NUTier at xxx>, <NUTier at yyy>], [<NUFlow at aaaa>, <NUFlow at bbbb>, <NUFlow at cccc>]]


.. method:: children_fetcher_for_rest_name()

    Returns the fetcher for a given children ReST name.

    Example:

        >>> print application.children_fetcher_for_rest_name(NUFlow.rest_name)
        <NUFlowsFetcher at yyyy>


.. method:: children_fetchers()

    Returns a list of all children fetchers of the object.

    Example:

        >>> print application.children_fetchers()
        [<NUTiersFetcher at xxxx>, <NUFlowsFetcher at yyyy>]


This allows complete abstract programatic operations on any objects.

For instance, the following function will create a new :py:class:`NUMetadata` to the entire hierarchy of children from a given object that has been created before a certain date:

.. code-block:: python
    :linenos:

    def apply_metadata_to_all_children(root_object, metadata, filter=None):

        # Loop on all declared children fetchers
        for fetcher in root_object.children_fetchers():

            # Fetch the list of the children
            (_, _, children, connection) = fetcher.fetch(filter=filter)

            # Ignoring connection errors
            if not connection.response_code == 200:
                continue

            # Loop on all fetched children
            for child in children:

                # Add the metadata to the current children
                child.create_child_object(metadata, async=True)

                # Start over recursively on the children of the current child
                apply_metadata_to_all_children(child, metadata)


    enterprise = NUEnterprise(id="xxxx-xxxx-xxx-xxxx")
    metadata = NUMetadata(name="my metadata", blob="hello world!")

    apply_metadata_to_all_children(enterprise, metadata, filter="creationDate > '01-01-2015'")



Authentication
---------------------
We talked about how to do a lot of things, but all of them needs to be done once your are authenticated. This section describes how to authenticate yourself.


NURESTLoginController
+++++++++++++++++++++

:py:class:`NURESTLoginController` is the class that manages a current authenticated ReST session. It is used by :py:class:`NURESTConnection` to correctly populate the user crendentials. This class contains several poperties.

.. attribute:: user

    The user login.

.. attribute:: password

    The password, in clear text. (clear text is mandatory for LDAP based authentication). This password is only used once to get the API key.
    All subsequent calls will use the API key.

.. attribute:: enterprise

    The enterprise name the user belongs to.

.. attribute:: api_key

    The API key to use instead of the password. This is mandatory for all calls other than `/me`

.. attribute:: url

    The VSD Server ReST API endpoint. Usually it `https://vsd-host:8443`

In order to populate the API key it is mandatory to do a call with the `/me` API using the :py:class:`NURESTUser`. Here is a full login example:

.. code-block:: python
    :linenos:

    login_controller = NURESTLoginController()
    login_controller.user = "csproot"
    login_controller.enterprise = "csp"
    login_controller.password = "secret"
    login_controller.url = "https://myvsd:8443/nuage/api/3_1"

    current_user = NURESTUser.get_default()
    current_user.fetch()
    login_controller.api_key = current_user.api_key

    # business as usual

Pretty painful... but there's an easy way.


NUVSDSession
++++++++++++

VSDK provides a shortcut to do all of this in one line, the :py:class:`NUVSDSession`. The previous section's code is strictly equivalent to the following:

.. code-block:: python
    :linenos:

    session = NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://myvsd:8443", version="3.2")
    session.start()
    current_user = session.user

    # business as usual



NURESTPushCenter
----------------

The VSD API supports client side push through a long polling connection. ReST clients can connect to that channel and will get a notification as soon as he or someone else in the system changes something. This events are filtered by permissions, which means that if someone change a property of an object you cannot see, you won't get notified. VSDK provides the :py:class:`NURESTPushCenter`, which is a singleton that encapsulates the logic to deal with this event channel. It runs in its own thread and will call registered callbacks when it receives a push.

Using the NURESTPushCenter
++++++++++++++++++++++++++

Only 4 methods are important:

.. method:: start()

    Starts to listen events.


.. method:: stop()

    Stops the push center.


.. method:: add_delegate(callback)

    Register a delegate function or a method to be called when a push is received. The prototype of a the callback function must be the following:

    .. code-block:: python

        def on_receive_push(data)

    :py:attr:`data` is a dictionary containing the encoded raw push JSON structure.


.. method:: remove_delegate(callback)

    Unregister a registered delegate function or a method.


Simple Example
++++++++++++++

Here is an sample code that will print the push data on every push:

.. code-block:: python
    :linenos:

    NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://vsd:8443" version="3.2").start()

    def on_receive_push(data):
        print(data);

    NURESTPushCenter().add_delegate(on_receive_push);
    NURESTPushCenter().start()

    # default stupid run loop. don't do that in real life :)
    while True:
        sleep(1000)


Advanced Example
++++++++++++++++

A more interesting use case:

.. code-block:: python
    :linenos:

    class EnterpriseUsersController (Object):

        def __init__(self, parent_enterprise):

            self.parent_enterprise = parent_enterprise

            # we assume the push center is already configured
            NURESTPushCenter().add_delegate(self.on_receive_user_push)

        def on_receive_user_push(self, data):

            # a single push can contains multiple events as they are clobbed together by the server if needed
            for event in data["events"]:

                # if the push is not about users, we don't care
                if event["entityType"] != NUUser.rest_name:
                    continue

                # We get the data. Server sends an array of entities, but it can contains only one object
                user_info = event["entities"][0]

                # if the pushed user is not part of the parent enterprise, we also don't care
                if user_info["parentID"] != self.parent_enterprise.id:
                    continue

                # create a transient NUUser from the data
                pushed_user = NUUser(data=user_info)

                if event["type"] == "CREATE":
                    # locally insert the object in the correct children list
                    self.enterprise.add_child(pushed_user)

                elif event["type"] == "UPDATE":
                    # locally replace a user with the new version in the correct children list
                    self.enterprise.update_child(pushed_user)

                elif event["type"] == "DELETE":
                    # locally remove the user from the correct children list
                    self.enterprise.remove_child(pushed_user)


    NUVSDSession(username="csproot", password="secret", enterprise="csp", api_url="https://vsd:8443" version="3.2").start()

    enterprise = NUEnterprise(id=some_id)
    enterprise_users_controller = EnterpriseUsersController(enterprise)

    # from now on, the user list of enterprise will always be up to date from the server!

    while True:
        sleep(1000)

