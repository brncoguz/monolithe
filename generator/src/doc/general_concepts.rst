General Concepts
================


Introduction
------------

VSDK provides a set of objects that allows the manipulation of VSD entities very easily. It deals with all possible CRUD operations. VSDK is based on `Bambou`, which defines all these low level operations. You will never use `Bambou` directly when working with VSDK. However, you need to understand the basics of this library, because all the logic resides in it. VSDK objects are simple autogenerated objects that are all inherited from the same `Bambou` class and they all work the same.

`Bambou` is composed of the following objects:

.. class:: NURESTConnection

    A low level class that is used each time there's a need to communicate with the VSD server.

.. class:: NURESTModelController

    Singleton that controls all defined model objects.

.. class:: NURESTUser

    Represents the user used for authentication and fetching root objects.

.. class:: NURESTLoginController

    Represents a ReST communication session, using a `NURESTUser` for authentication.

.. class:: NURESTObject

    Parent class of all ReST entities. All VSDK objects are inheriting from this class.

.. class:: NURESTFetcher

    Class used to get children of a `NURESTObject`.

.. class:: NURESTPushCenter

    Class that deals with intercepting and rerouting VSD ReST Push Notifications.


.. note:: The most important classes you need to know are :py:class:`NURESTObject`, :py:class:`NURESTFetcher` and :py:class:`NURESTPushCenter`.



NURESTObject
------------

:py:class:`NURESTObject` is the parent class of all VSDK entities.


ReST Names
++++++++++++++++++++

All :py:class:`NURESTObject` subclasses **must** implement a given method that will return the actual ReST name of the objects. For instance, the ReST name of  a VSD enterprise is `enterprise` while it is `egressacltemplate` for Egress Security Policies. This name is used to forges API and also can be used as an unique key for identifying random VSDK objects.

.. note:: ReST names are auto generated. You never need to manually define them.


ReST API URI generation
++++++++++++++++++++++++++++

:py:class:`NURESTObject` is able to forge all the URI needed to interact with the server through the ReST API.

For instance, if an object with a ReST name set to `object` needs to get the list of children with ReST name set to `subobject`, `Bambou` will create the following endpoing URL `/objects/{id}/subobjects`. if an object with a ReST name set to `object` needs to fetch itself, the generated URL will be `/objects/{id}`

`Bambou` deals with plural. So when using the VSDK the only URL you will ever enter is the VSD API base URL endpoint.

.. note:: The ReST base URL is pulled from the session. We'll discuss this later.


Exposing ReST attributes
++++++++++++++++++++++++

Exposed attributes will be converted and sent to the server when you do CRUD operations. That way, if an object has an attribute :py:attr:`name`, it can be marked as a ReST attribute. When saving the object, the value of :py:attr:`name` will be put into the JSON structure that will be sent to the server, or automatically populated from a JSON structure coming from the server.

Not only the attribute can be exposed, but also its type and other informations like read only, allowed values, format etc.

.. note:: exposing ReST Attributes is also auto generated. You never need to manually expose new attributes.


CRUD Operations
+++++++++++++++

:py:class:`NURESTObject` allows to perform all sorts of CRUD operations.

.. method:: fetch([callback=None])

    Gets the latest version of the object from the server.

    Example:

        >>> enterprise = NUEnterprise(id="xxx-xxx-xxx-xxx")
        >>> enterprise.fetch() # will get the enterprise with id "xxx-xxx-xxx-xxx"
        >>> print enterprise.name
        "My Enterprise"


.. method:: save([callback=None])

    Saves the current state of the object in the server.

    Example:

        >>> enterprise.name = "My Super Enterprise"
        >>> enterprise.save() # will save the new name in the server


.. method:: delete([callback=None])

    Deletes the object from the server.

    Example:

        >>> enterprise.delete() # will delete the enterprise from the server


.. method:: add_child_object(nurest_object[, callback=None])

    Creates another :py:class:`NURESTObject` as a child of the current object.

    Example:

        >>> group = NUGroup(name="Super Guys")
        >>> enterprise.add_child_object(group) # the new group as been created in the enterprise


.. method:: assign_objects(objects, nurest_object_type[, callback=None])

    Assigns a bunch of objects to the current object (for instance, putting users into a group).

    Example:

        >>> group.assign_objects([user1, user2, user3]) # user1, user2 and user3 are now part of the group


.. method:: instantiate_object(nurest_object, from_template[, callback=None])

    Creates the object as an instance of the given template.

    Example:

        >>> domain = NUDomain(name="my instance")
        >>> domain.instantiate_child_object(domain_template) # the domain as been instanciated from the template domain_template


.. note:: All these methods require the current :py:class:`NURESTObject` to have a valid :py:attr:`ID`.

.. note:: You may notice that there is no creation method. Creation is always happening from a parent object and is done using.

.. note:: You may notice that an optional parameter :py:attr:`callback` is present. VSDK can work in a completely asynchronous mode. We'll explain this later.



Converting to and from a Python Dictionary
+++++++++++++++++++++++++++++++++

:py:class:`NURESTObject` allows quick and easy conversion from and to python dictionaries

.. method:: from_dict(dictionary)

    Sets all the exposed ReST attribues from the given dictionary

    Example:

        >>> info = {"name": "my group", "private": False}
        >>> group = NUGroup()
        >>> group.from_dict(info)
        >>> print "name: %s - private: %s" % (group.name, group.private)
        "name: my group - private: False"


.. method:: to_dict()

    Convert the current object into a Dictionary using all exposed ReST attributes

    Example::
        >>> print group.to_dict()
        {"name": "my group", "private": False, "ID": "xxxx-xxx-xxxx-xxx", ...}

.. note:: you never need to process to the actual JSON conversion when sending info to the server. :py:class:`NURESTConnection` will do that automatically.



NURESTFetcher
-------------

:py:class:`NURESTFetchers` are objects allowing a :py:class:`NURESTObject` to fetch its children :py:class:`NURESTObjects`. All :py:class:`NURESTObjects` have one or more fetchers, unless it's a final object in the VSD model hierarchy. :py:class:`NURESTFetcher` provides a lot of possibility regarding the way you want to get a given children list. It can deal with simple object fetching, pagination, filtering, request headers, grouping etc.


Fetching Children List
++++++++++++++++++++++

:py:class:`NURESTFetcher` has one important method:

.. method:: fetch([filter=None[, order_by=None[, group_by=[][, page=None[, page_size=None[, commit=True[, async=False[, callback=None]]]]]]]])

    Gets the list of children objects it manages and add them into the its :py:class:`NURESTObject` declared list.
    For instance a :py:class:`NUUsersFetcher` of :py:class:`NUEnterprise` will get a list of :py:class:`NUUser` and put them into the property :py:attr:`users`
    of the :py:class:`NUEnterprise`.

    Returns:

        Tuple containing the fetcher itself, the fetcher owner, the list of fetched objects and the :py:class:`NURESTConnection` that was used. You don't need
        to use this tuple is you work in synchronous mode.

    Example:

        >>> myenterprise.domains_fetcher.fetch() # fetch domains in an enterprise
        >>> print myenterprise.domains # print the list of fetched objects
        [<NUDomain at xxx>, <NUDomain at yyyy>, <NUDomain at zzz>]


Discussion about Fetchers
++++++++++++++++++++++++

Fetcher is a powerfull concept that makes the process of getting child objects completely generic and code friendly. :py:class:`NURESTObject` provides methods that allow to deal programatically with the fetchers and children lists in a completely generic way.

.. method:: registered_children_rest_names()

    Gets the list of all possible children ReST names.

    Example:

        >>> application = NUApplication()
        >>> application.registered_children_rest_names()
        ["flow", "tier"]


.. method:: children_list_for_rest_name(rest_name)

    Gets a particular children list based on a given ReST name.

    Example:

        >>> application = NUApplication(id="xxx-xxx-xxx")
        >>> application.tiers_fetcher.fetch()
        >>> print application.children_list_for_rest_name(NUTier.rest_name())
        [<NUTier at xxx>, <NUTier at yyy>]


.. method:: registered_children_fetchers()

    Returns a list of all fetchers of the object.

    Example:

        >>> print application.registered_children_fetchers()
        [<NUTiersFetcher at xxxx>, <NUFlowsFetcher at yyyy>]


.. method:: children_fetcher_for_rest_name()

    Returns the fetcher for a given children ReST name.

    Example:

        >>> print application.children_fetcher_for_rest_name(NUFlow.rest_name())
        <NUFlowsFetcher at yyyy>


This allows complete abstract programatic operations on any objects.

For instance, the following function will create a new :py:class:`NUMetadata` to the entire hierarchy of children from a given object that has been created before a certain date:

.. code-block:: python
    :linenos:

    def apply_metadata_to_all_children(root_object, metadata, filter=None):

        # Loop on all declared children ReST names
        for children_rest_name in root_object.registered_children_rest_names():

            # Fetch the list of the children
            (_, _, children, connection) = root_object.children_fetcher_for_rest_name(children_rest_name).fetch(filter=filter)

            # Ignoring errors
            if not connection.response_code == 200:
                continue

            # Loop on all fetched children
            for child in children:

                # Add the metadata to the current children
                child.add_child_object(metadata, async=True)

                # Start over recursively on the children of the current child
                apply_metadata_to_all_children(child, metadata)


    enterprise = NUEnterprise(id="xxxx-xxxx-xxx-xxxx")
    metadata = NUMetadata(name="my metadata", blob="hello world!")

    apply_metadata_to_all_children(enterprise, metadata, filter="creationDate > '01-01-2015'")



